#include "trellis.h"

/* ============================================================================
 *  Trellis definition for NSC (Non-Systematic Convolutional Code) — Rate 1/2
 *  ============================================================================
 *
 *  本ファイルでは、2-bit shift register（状態数 4）を持つ
 *  レート 1/2 の非系統的畳み込み符号器の trellis を定義する。
 *
 *  符号器のレジスタ状態は以下の 4 通り:
 *
 *      STATE_A : 00
 *      STATE_B : 01
 *      STATE_C : 10
 *      STATE_D : 11
 *
 *  入力ビット b ∈ {0,1} に対して
 *
 *      - 出力ビット列 (v, w)
 *      - 次状態 next_state
 *
 *  をテーブルとして定義する（if 文なしの高速実装用）。
 *
 * ---------------------------------------------------------------------------
 *  ※ この trellis は、ユーザが自由に選択する生成多項式 (generator polynomial)
 *     による汎用構造ではなく、研究デモ用に固定された “NSC 標準例”。
 *
 *     よって生成多項式 133, 171 (octal) のような K=7 の系統的符号ではなく、
 *     K=3（2-bit 状態）の非系統的構成を採用していることに注意。
 *
 *     典型的な構造:
 *         - 2-bit shift register (constraint length = 3)
 *         - systematic ではない → 出力は (v,w)
 * のみ（入力ビットはそのまま出さない）
 * ---------------------------------------------------------------------------
 *
 *  trellis.h にて STATE_A〜STATE_D の enum 対応を提供。
 *
 * ========================================================================== */

/* ============================================================================
 *  出力ビットテーブル nsc_output_bits[state][input_bit][2]
 *  --------------------------------------------------------------------------
 *  各状態 + 入力ビットに対して出力される 2bit (v,w)
 *
 *  例：
 *      nsc_output_bits[STATE_A][0] = {0,0}
 *      nsc_output_bits[STATE_A][1] = {1,1}
 *
 *  読み方：
 *      state = 00 で input=1 → 出力 11 → 次状態は 10（=STATE_C）
 * ========================================================================== */
const int nsc_output_bits[4][2][2] = {

    /* ----------------------------------------------------------------------
     * STATE_A : shift register = 00
     * ------------------------------------------------------------------ */
    {
        {0, 0}, /* input 0 → 出力 00 → next = STATE_A */
        {1, 1}  /* input 1 → 出力 11 → next = STATE_C */
    },

    /* ----------------------------------------------------------------------
     * STATE_B : shift register = 01
     * ------------------------------------------------------------------ */
    {
        {1, 1}, /* input 0 → 出力 11 → next = STATE_A */
        {0, 0}  /* input 1 → 出力 00 → next = STATE_C */
    },

    /* ----------------------------------------------------------------------
     * STATE_C : shift register = 10
     * ------------------------------------------------------------------ */
    {
        {0, 1}, /* input 0 → 出力 01 → next = STATE_B */
        {1, 0}  /* input 1 → 出力 10 → next = STATE_D */
    },

    /* ----------------------------------------------------------------------
     * STATE_D : shift register = 11
     * ------------------------------------------------------------------ */
    {
        {1, 0}, /* input 0 → 出力 10 → next = STATE_B */
        {0, 1}  /* input 1 → 出力 01 → next = STATE_D */
    }};

/* ============================================================================
 *  次状態テーブル nsc_next_state[state][input_bit]
 *  --------------------------------------------------------------------------
 *  シフトレジスタの状態遷移。
 *
 *      新しい状態 = (state << 1) + input_bit （下位2bitで管理）
 *
 *     ただしこの実装では、明示的にテーブル化して高速化する。
 * ========================================================================== */
const int nsc_next_state[4][2] = {
    /* STATE_A (00) */ {STATE_A, STATE_C}, /* input 0 → 00, input 1 → 10 */
    /* STATE_B (01) */ {STATE_A, STATE_C}, /* input 0 → 00, input 1 → 10 */
    /* STATE_C (10) */ {STATE_B, STATE_D}, /* input 0 → 01, input 1 → 11 */
    /* STATE_D (11) */ {STATE_B, STATE_D}  /* input 0 → 01, input 1 → 11 */
};
